---
layout: mypost
title: 二分法初学
categories: [C++]
---

### 二分

二分法，就是取中点、缩小范围、逐渐得出答案的算法。呵呵。


【问题 PRS7+】给目标`t`与一组数`v`，找`t`在`v`中的位置，若有多个`t`则随便找一个

*解：*

先定左`left`右`right`，循环算`mid`，如果大就取左区间（`right = mid-1`）、小就右（`left = mid+1`）。
1. 据说`left <= right`是较标准的while循环条件
2. 修改`mid`后，新区间不含`mid`本身，因为`v`里可能无`t`

C++

```c++
#include <bits/stdc++.h>
using namespace std;
#define endl "\n"
signed main() {
    int n/*数组长度*/, t/*寻找目标*/;
    cin >> n >> t;
    vector<int> v(n)/*数组*/;
    for (int i = 0; i < n; i++) { cin >> v[i]; }
    sort(v.begin(), v.end());

    int left = 0;
    int right = n-1;
    while (left <= right)
    {
        int mid = (left + right) / 2;
        if (v[mid] < t) {
            left = mid + 1;
        }
        else if (v[mid] > t) {
            right = mid - 1;
        }
        else {
            cout << mid << endl;
            return 0;
        }
    }
    cout << "没找到" << endl;
}
```



【问题 FTR9+】U263308 河中跳房子

奶牛在河里跳石头。

- 起点和离起点L远 (1≤L≤1,000,000,000) 的终点处均有一个岩石
- 共有N (0 ≤ N ≤ 50,000) 个岩石
- 每个岩石与起点的距离分别为Di (0<Di<L)
- 现在移走**除起终点外**的**至多**M (0≤M≤N) 个岩石，问最长可能的最短跳跃距离是多少？也就是说，按一定方法移除M个现有的石头，石头之间能达到最长的最短距离是多少？

【输入】L起终点距离、N岩石数、M最大移除岩石数、N个Di岩石位置

【输出】最长的最短距离

*解：*

提到“最长的最短”或者“最短的最长”，大概是二分。

为了让`mid`变成最终答案，这样定义`left`、`right`：

```c++
int left = 0, right = L+1;
```

然后在循环中计算并判断，需要移除几个石头。如`移除数>M`，说明间距大了，`right=mid-1`；`移除数<M`就`left=mid`，这里没有`-1`是因为最终答案大于或**等于**`mid`。

完整代码暂时先贴个别人的，里面也有原题：[CSDN@xcdq](https://blog.csdn.net/xcdq_aaa/article/details/105563833)

【问题 FTR9】CF1902B Getting Points

`n`天，每7天下达1个任务，每1天有1节课。每天可选择休息或工作。如选择工作，每天可最多上1节课和完成≤2个任务。

上一次课奖励`l`点数，完成一次任务奖励`t`点数。要求达成`p`点数的情况下，求最大休息时间？（详见[原题](www.luogu.com.cn/problem/CF1902B)）

【输入】天数`n`、点数`p`、上课奖励`l`、任务奖励`t`

【输出】最大休息天数

*解：*

用`mid`猜测天数，算`mid`天最多能获得多少点数，大了区间左移，反之右移。

任务奖励和：`min(2*mid, ceil(n/7.0))`

上课奖励和：`mid * l`

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
void solve() {
    int n/*天数*/, p/*点数*/, l/*上课奖励*/, t/*任务奖励*/;
    cin >> n >> p >> l >> t;
 
    int week = ceil(n / 7.0);
    int left = 0, right = n, cost = -1;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (t * min(2*mid, week) + mid*l >= p) {
            cost = mid;
            right = mid - 1;
        }
        else {
            left = mid + 1;
        }
    }
    cout << n - cost << endl;
}
 
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int tc;
    cin >> tc;
    while (tc--) {
        solve();
    }
}
```