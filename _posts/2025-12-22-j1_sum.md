---
layout: mypost
title: 算法题复盘 积分赛第一场
categories: [算法]
---

Start Time: Dec/21/2025 18:00UTC+8, Dur: 4h

**A. Abducting Nathan**

纯纯英语题，恶心人，已ac

**B. Best University ID**

给定几组string和int，输出**质因数最大**的int所对应的string。

读题读错成找最大质数了。从test4、test7 WA到test8也是有技术的

下面是题解给的求10000以内质数模板，实际还能优化

```c++
vector<int> zhi;
bool is_zhi(int x) { 
    for (int i = 2; i < x; i++)
    {
        if (x % i == 0) {
            return false;
        }
    }
    return true;
}
void cal_zhi() {
    for (int i = 2; i < 10010; i++)
    {
        if (is_zhi(i)) {
            zhi.push_back(i);
        }
    }
}
```

**C. CCM**

由于压迫感，这题没有开。

题目给定整数`X`、`Y`、浮点`Vcr`、`Vma`

因此已知三人位置 Cris (0,0) Carlinhos (X,0) Marcel (X/2,Y)、以及Cris和Marcel吹气球的速度，求Carlinhos吹气球速度至少为多少，使得气球碰到/无法再吹时，Carlinhos的气球面积≥其他人的面积

题解给到二分搜索方法

```c++
double x, y;
double Vcr, Vma;
cin >> x >> y >> Vcr >> Vma;

double d = sqrt((x/2.0)*(x/2.0) + y*y);
double l = Vcr, r = 1e18;

for (int i = 0; i < 100; i++)
{
    double Vca = (l + r) / 2;
    // 1. 计算第一阶段时间
    double t1 = x / (Vcr + Vca);
    double Rcr = Vcr * t1;
    double Rca = Vca * t1;
    // 2. Marcel 开始吹，直到碰到其中一个
    // 碰到 Cris 需要的时间：(dist - Rcr) / Vma
    // 碰到 Carlinhos 需要的时间：(dist - Rca) / Vma
    // Marcel 会取较短的那个时间停止
    double t2 = min((d-Rcr)/Vma, (d-Rca)/Vma);
    double Rma = Vma * t2;
    // 3. 判断条件：Carlinhos 的半径是否不小于 Marcel 的半径
    // (因为 low = Vcr 开始二分，所以 Rca >= Rcr 已经默认满足)
    if (Rca >= Rma) {
        r = Vca;
    } else {
        l = Vca;
    }
}
cout << fixed << setprecision(15);
cout << r << endl;
```

**D. Diary of Hapiness**

纯送

**E. El Classificador**

你有一个存有 $n$ 双鞋的仓库。每来一个要求尺码至少为 $x$ 的客人，你就卖给他满足条件的最小尺码。卖掉的鞋立刻出库，如果没鞋符合要求就回复 -1。

因为暴力解法TLE了

1. 管理库存：将 n 个鞋码存入一个能自动排序的数据结构。

2. 查找并移除：对每个客户要求的尺码 x，利用 lower_bound 快速找到大于或等于 x 的最小值，并将其从库存中删除。

3. 输出结果：如果找到了符合条件的则输出该值，如果库存中没有则输出 -1。

题解很关键的一点：通过 **`s.lower_bound(x)`** 寻找满足 Si ***大于等于*** x 的最小鞋码，返回迭代器`pos`。这是我的知识盲区

`pos == s.end()`没找到，`*pos`表示该值

```c++
int n, q;
cin >> n >> q;

multiset<int> s;
for (int i = 0; i < n; i++) {
    int temp;
    cin >> temp;
    s.insert(temp); 
}

while (q--) {
    int x;
    cin >> x;
    
    // 找到第一个大于等于 x 的位置
    multiset<int>::iterator pos = s.lower_bound(x);

    if (pos == s.end()) {
        cout << -1 << "\n";
    } else {
        cout << *pos << "\n"; // 输出找到的鞋码
        s.erase(pos);         // 只删除当前这一双鞋
    }
}
```

**F. Food Queue**

比较简单，我的做法没过脑直接整4个数组，ac

**G. Grand Meeting**

比较简单，注意两个站点重合的情况。ac

**H. Harada Football Clube**

直接模拟较困难，通过观察，并计算验证了两组input和output，可注意到：`out/(input-3) = input/2-1`，即`out=(input-3)*(input/2-1)`，为浮点运算，输出时不带小数点即可，核心部分一行代码解决，很神奇，ac

**I. Irritating Carlinhos**

简单模拟，ac

**J. Journey through time**

不知道为什么`#define int long long`被注释掉了，然后导致WA，唉不知道在干嘛

我的做法是给所有指令按照重新排一遍序，然后再顺序执行，再将执行结果按照原顺序输出